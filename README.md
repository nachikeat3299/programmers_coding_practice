## 2020년 1월 9일  

- 로컬 .git을 gitHub에 `remote add` 시킴.

### 16. 소수 찾기 (1h)

- 에라토스테네스의 체를 이용함

- __언어를 Ruby로 설정하여 곤욕을 겪음__

---

### 17. 수박수박수박수박수박수? (4m)

- pass

### 18. 문자열을 정수로 바꾸기 (17m)

- `int()`로 바꾸는 것이 너무 쉬워서 다른 방법을 시도해 보았지만, 결국 `int()`를 사용하게 되었다.
---

## 2020년 1월 10일 

### 19. 시저 암호

- 새로운 문자열 참조표를 만들어 풀이.   
- 처음에 문자열 참조표를 거꾸로 붙여서 오답.  
* _jh_ 님의 풀이에서 배울 만한 점은 다음과 같다.
    - 파이썬의 `ord(c)` 내장 함수는 문자 `c`의 아스키 코드 값을 돌려주는 함수이다. 
    - 파이썬의 `chr(a)` 내장 함수는 아스키 코드 값 `i`를 입력받아 그 코드에 해당하는 문자를 출력한다.
    - 파이썬의 `ord(c)` 내장 함수와 `chr(a)`내장 함수는 쓰임새가 서로 반대이다.
    - [여기](www.asciitable.com)에서 아스키 코드를 참조할 수 있다.
        - 알파벳 소문자(`a` ~ `z`)의 아스키 코드 범위는 `97` ~ `122`이다.
        - 알파벳 대문자(`A` ~ `Z`)의 아스키 코드 범위는 `65` ~ `90`이다.

### 20. 약수의 합

- 제곱수의 경우 몫은 포함시키면 안 되는데 포함시켜버림.  
- __몫 연산자 `//`__

---

## 2020년 1월 12일

### 21. 이상한 문자열 만들기 (3h)

- 시퀀스 내에서 해당하는 값의 인덱스를 찾을 때에는 `index()`를 쓴다.
- 시퀀스가 문자열이라면 `find()`도 쓸 수 있다.
- 다만 시퀀스에 중복된 요소가 들어 있을 때에는 아무런 소용이 없는 듯 하다... 예를 들어 `s = "abbc"`이고 `s.index('b')`는 오로지 `1`만 리턴한다.
- 정말 푸는데 오래 걸렸다..
- 문자열을 다루는 방법이 어려운 것 같다. 단어와 한 개 이상의 공백을 분리하는 것에 시간을 많이 소요했다. 특히, 공백으로 시작하거나 끝나는 경우 마지막 조립 하는데에도 헷갈렸던 것 같다. 연속된 공백을 분리할 때 마지막 공백 덩어리 처리하는 것이 어려웠다.
* _jh_ 님의 풀이에서 배울 만한 점은 다음과 같다.
    - 파이썬의 `enumerate(g)` 내장 함수는 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을  포함하는 `enumerate` 객체를 돌려준다. 보통의 `enumerate`함수는 다음 예제처럼 `for`문과 함께 자주 사용한다.
        ~~~
        >>> for i, name in enumerate(['body', 'foo', 'bar']):
        ...    print(i, name)

        0 body
        1 foo
        2 bar
        ~~~
    - `enumerate`를 `for`문과 함께 사용하면 자료형의 현재 순서(index)와 그 값을 쉽게 알 수 있다. `for`문처럼 반복되는 구간에서 객체가 현재 어느 위치에 있는지 알려 주는 인덱스 값이 필요할 때 `enumerate` 함수를 사용하면 매우 유용하다.

### 22. 자릿수 더하기 (5m)

- 자릿수 더하는 건데 그냥 분해해버려서 똑같은 결과가 나와서 잠시 당황
* _jh_ 님의 풀이에서 배울 만한 점은 다음과 같다.
    - 파이썬 내장 함수 `map(f, iterable)`은 함수(`f`)와 반복 가능한 자료형(`iterable`)을 입력으로 받는다. `map`은 입력받은 자료형의 각 요소를 함수 `f`가 수행한 결과를 묶어서 돌려주는 함수이다. 다음 예를 보자.
        ~~~
        >>> def two_times(numberList):
        ...     result = []
        ...     for number in numberList:
        ...         result.append(number * 2)
        ...     return result

        >>> result = two_times([1, 2, 3, 4])
        >>> print(result)
        [2, 4, 5, 8]
        ~~~
    - `two_times`함수는 리스트 요소를 입력받아 각 요소에 2를 곱한 결괏값을 돌려준다
    - 위 예제는 `map` 함수를 사용하면 다음처럼 바꿀 수 있다.
        ~~~
        >>> def two_times(x):
        ...     return x * 2

        >>> list(map(two_times, [1, 2, 3, 4])
        [2, 4, 6, 8]
        ~~~

---

### 23. 자연수 뒤집어 배열로 만들기

- 리스트 요소들의 순서를 거꾸로 바꿀 때에는 `LIST_NAME.reverse()`를 사용한다.

### 24. 정수 내림차순으로 배치하기

- 리스트 요소들을 정렬할 때, 기본은 __내림차순__이며 오름차순으로 하고 싶을 때에는 옵션으로 `reverse=True`를 준다.

---

## 2020년 1월 13일

### `testBench.py` 추가

- 테스트케이스와 답안 추가를 빠르게 하기 위한 `testBench.py`파일 설계.
- `zip(*iterable)`은 동일한 개수로 이루어진 자료형을 묶어 주는 역할을 하는 함수이다. 예를 들면 아래와 같다.

    ~~~
    >>> list(zip([1, 2, 3], [4, 5, 6]))
    [(1, 4), (2, 5), (3, 6)]

    >>> list(zip("abc", "def"))
    [("a", "d"), ("b", "e"), ("c", "f")]
    ~~~
- `solution` 함수의 실행 시간을 재기 위해서 `time` 라이브러리를 추가함. `time.tim()` 구문은 운영체제마다 다른 기준 시간으로부터 현재 시간 까지 몇 초가 흘렀는지 초(s) 단위를 사용하여 반환한다.
- 객체 `s` 가 문자열인지 판단하기 위해서 `isinstance(s, str)`을 사용하였다.
- `solution` 함수에 인자가 전달 될 때, mutable한 객체가 전달되는 경우 `solution`에서의 변화가 클래스 변수에 그대로 영향을 끼쳤었다. 따라서 `copy`라이브러리의 `deepcopy` 메서드를 통해서 mutable한 객체를 복사하여 전달하였다. 참고로,
- 함수의 인자가 몇 개인지 조사하기 위해서 `inspect`라이브러리에서 `signature`메소드를 임포트하였다. `signature(function_name).parameters)`로 `function_name`함수의 인자를 반환할 수 있다.
    - 단순 객체 복제는, 그 객체가 mutable한 객체일 때, 동일한 참조를 만드므로 객체의 수정은 참조하고 있는 모든 변수들에 영향을 끼친다.
        ~~~
        >>> a = [1, 2, 3, 4]
        >>> b = a
        >>> a
        [1, 2, 3, 4]
        >>> b
        [1, 2, 3, 4]
        >>> b[0] = 99
        >>> a
        [99, 2, 3, 4]
        >>> b
        [99, 2, 3, 4]
        ~~~
    - mutable하지 않은 객체는 위와 같은 이슈가 발생하지 않는다.
        ~~~
        >>> a = "abc"
        >>> b = a
        >>> a
        abc
        >>> b
        abc
        >>> b = 10
        >>> a
        abc
        >>> b
        10
        ~~~
    - 얕은 복사(shallow copy)는 mutable한 객체를 새로이 복사하지만, 객체의 각 요소들은 기존 요소들의 참조이다.
        ~~~
        >>> import copy
        >>> a = [1, [2, 3]]
        >>> b = copy.copy(a)
        >>> a
        [1, [2, 3]]
        >>> b
        [1, [2, 3]]
        b.append(4)
        >>> a
        [1, [2, 3]]
        >>> b
        [1, [2, 3], 4]
        >>> b[1].append('a')
        >>> a
        [1, [2, 3, 'a']]
        >>> b
        [1, [2, 3, 'a'], 4]
        ~~~
    - 깊은 복사(deep copy)는 mutable한 객체와 그 요소들까지 모두 새로이 복사한다. 완전히 독립적인 개체가 만들어진다.`
        ~~~
        >>> import copy
        >>> a = [1, [2, 3]]
        >>> b = copy.deepcopy(a)
        >>> a
        [1, [2, 3]]
        >>> b
        [1, [2, 3]]
        b.append(4)
        >>> a
        [1, [2, 3]]
        >>> b
        [1, [2, 3], 4]
        >>> b[1].append('a')
        >>> a
        [1, [2, 3]]
        >>> b
        [1, [2, 3, 'a'], 4]
        ~~~
* 클래스에 대해서
    - __속성(attribute)__
        - 속성은 공개/비공개 여부에 따라서 공개(public) 속성과 비공개(private) 속성으로 나뉜다.
        - 비공개 속성은 속성명 앞에 언더바 두개(`\_\_`)를 붙이면 되며, 이것은 인간의 구별 관행이며 컴퓨터는 공개/비공개를 따로 구분하지 않는다.
        - 속성은 또한 클래스에 속하는지 객체(instance)에 속하는지의 여부에 따라서 클래스 속성과 인스턴스 속성으로 나뉜다.
    - __메서드(method)__
        - 메소드는 인스턴스 메서드와 클래스 메서드, 정적 메서드로 나뉜다.
        - 인스턴스 메서드는 인스턴스가 생성 되어야만 사용할 수 있으며, 클래스 메서드와 정적 메서드는 인스턴스가 없어도 클래스만으로 호출할 수 있다.
        - 그 실행이 외부의 환경에 영향을 미치지 않을 때, 즉 부수 효과(side effect)가 없고 입력 값이 같으면 언제나 같은 값을 반환하는 순수 함수(pure function)인 경우에 사용한다. 
        - 클래스 메서드는 메서드 안에서 클래스 속성, 클래스 메서드에 접근해야 할 때 사용한다.
    - 속성과 메서드에 관한 예제는 다음과 같다.
        ~~~
        >>> class Person:
        ...    person_count = 0
        ...    def __init__(self, _height, _weight):
        ...        Person.person_count += 1
        ...        self.height = _height 
        ...        self.weight = _weight
        ...
        ...    def grow(self):
        ...        self.height += 1
        ...        self.weight += 1
        ...
        ...    @classmethod
        ...    def person_count_sub(cls):
        ...        cls.person_count -= 1
        ...    @classmethod
        ...    def create_persont(cls, _height, _weight):
        ...        p = cls(_height, _weight)
        ...        return p
        ...
        ...    @staticmethod
        ...    def just_add(a, b):
        ...        return a + b

        >>> jaemin = Person(191, 91)
        >>> Person.person_count
        1
        >>> jaewon = Person(168, 50)
        >>> Person.person_list.append("jaewon")
        >>> Person.person_count
        2
        >>> jaemin.height
        191
        >>> jaemin.grow()
        >>> jaemin.height
        192
        >>> Person.person_count_sub()
        >>> Person.person_count
        1
        >>> Person.just_add(2, 3)
        5
        >>> taejin = Person.create_person(170, 70)
        ~~~
---

## 2020년 1월 14일

### 25. 정수 제곱근 판별 0115
 - 테스트 케이스 하나가 통과되지 않아서 고민하였음. 1부터 해당 수의 제곱근까지의 숫자들로 해당 수를 나누면서, 둘이 같은 경우 제곱수라고 생각했는데, 17과 같은 수의 경우 4로 나누면 몫이 4 이지만, 제곱수는 아니다. 해당 수를 해당 수의 제곱근까지의 숫자로 나누었을 때 나머지가 0이라는 조건까지 추가해주어야 한다.

### 26. 제일 작은 수 제거하기
- pass

---

### 27. 홀수 짝수 판별하기
- pass

### 28. 최대공약수와 최소공배수
- 유클리드 호제법으로 최대공약수 구하기
    - 유클리드 호제법이란 어떤 두 수의 최대공약수는 두 수를 나눈 나머지와 한 수의 최대공약수와 같다는 것.
- 최대공약수가 G라면 두 수는 Ga, Gb로 표현할 수 있으며 최소공배수는 Gab이다.

---


### 29. 콜라츠 추측
- pass

## 2020년 1월 15일


