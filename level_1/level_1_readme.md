## 2020년 1월 9일  

- 로컬 .git을 gitHub에 `remote add` 시킴.

### 16. 소수 찾기 (1h)

- 에라토스테네스의 체를 이용함

- __언어를 Ruby로 설정하여 곤욕을 겪음__

---

### 17. 수박수박수박수박수박수? (4m)

- pass

### 18. 문자열을 정수로 바꾸기 (17m)

- `int()`로 바꾸는 것이 너무 쉬워서 다른 방법을 시도해 보았지만, 결국 `int()`를 사용하게 되었다.
---

## 2020년 1월 10일 

### 19. 시저 암호

- 새로운 문자열 참조표를 만들어 풀이.   
- 처음에 문자열 참조표를 거꾸로 붙여서 오답.  

> * _jh_ 님의 풀이에서 배울 만한 점은 다음과 같다.
>    - 파이썬의 `ord(c)` 내장 함수는 문자 `c`의 아스키 코드 값을 돌려주는 함수이다. 
>    - 파이썬의 `chr(a)` 내장 함수는 아스키 코드 값 `i`를 입력받아 그 코드에 해당하는 문자를 출력한다.
>    - 파이썬의 `ord(c)` 내장 함수와 `chr(a)`내장 함수는 쓰임새가 서로 반대이다.
>    - [여기](www.asciitable.com)에서 아스키 코드를 참조할 수 있다.
>        - 알파벳 소문자(`a` ~ `z`)의 아스키 코드 범위는 `97` ~ `122`이다.
>        - 알파벳 대문자(`A` ~ `Z`)의 아스키 코드 범위는 `65` ~ `90`이다.

### 20. 약수의 합

- 제곱수의 경우 몫은 포함시키면 안 되는데 포함시켜버림.  
- 몫 연산자 `//`

---

## 2020년 1월 12일

### 21. 이상한 문자열 만들기 (3h)

- 시퀀스 내에서 해당하는 값의 인덱스를 찾을 때에는 `index()`를 쓴다.
- 시퀀스가 문자열이라면 `find()`도 쓸 수 있다.
- 다만 시퀀스에 중복된 요소가 들어 있을 때에는 아무런 소용이 없는 듯 하다... 예를 들어 `s = "abbc"`이고 `s.index('b')`는 오로지 `1`만 리턴한다.
- 정말 푸는데 오래 걸렸다..
- 문자열을 다루는 방법이 어려운 것 같다. 단어와 한 개 이상의 공백을 분리하는 것에 시간을 많이 소요했다. 특히, 공백으로 시작하거나 끝나는 경우 마지막 조립 하는데에도 헷갈렸던 것 같다. 연속된 공백을 분리할 때 마지막 공백 덩어리 처리하는 것이 어려웠다.

> * _jh_ 님의 풀이에서 배울 만한 점은 다음과 같다.
    - 파이썬의 `enumerate(g)` 내장 함수는 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을  포함하는 `enumerate` 객체를 돌려준다. 보통의 `enumerate`함수는 다음 예제처럼 `for`문과 함께 자주 사용한다.
>        ~~~
>        >>> for i, name in enumerate(['body', 'foo', 'bar']):
>        ...    print(i, name)
>
>        0 body
>        1 foo
>        2 bar
>        ~~~
>    - `enumerate`를 `for`문과 함께 사용하면 자료형의 현재 순서(index)와 그 값을 쉽게 알 수 있다. `for`문처럼 반복되는 구간에서 객체가 현재 어느 위치에 있는지 알려 주는 인덱스 값이 필요할 때 `enumerate` 함수를 사용하면 매우 유용하다.

### 22. 자릿수 더하기 (5m)

- 자릿수 더하는 건데 그냥 분해해버려서 똑같은 결과가 나와서 잠시 당황
> * _jh_ 님의 풀이에서 배울 만한 점은 다음과 같다.
>    - 파이썬 내장 함수 `map(f, iterable)`은 함수(`f`)와 반복 가능한 자료형(`iterable`)을 입력으로 받는다. `map`은 입력받은 자료형의 각 요소를 함수 `f`가 수행한 결과를 묶어서 돌려주는 함수이다. 다음 예를 보자.
>        ~~~
>        >>> def two_times(numberList):
>        ...     result = []
>        ...     for number in numberList:
>        ...         result.append(number * 2)
>        ...     return result
>
>        >>> result = two_times([1, 2, 3, 4])
>        >>> print(result)
>        [2, 4, 5, 8]
>        ~~~
>    - `two_times`함수는 리스트 요소를 입력받아 각 요소에 2를 곱한 결괏값을 돌려준다
>    - 위 예제는 `map` 함수를 사용하면 다음처럼 바꿀 수 있다.
>        ~~~
>        >>> def two_times(x):
>        ...     return x * 2
>
>        >>> list(map(two_times, [1, 2, 3, 4])
>        [2, 4, 6, 8]
>        ~~~

---

### 23. 자연수 뒤집어 배열로 만들기

- 리스트 요소들의 순서를 거꾸로 바꿀 때에는 `LIST_NAME.reverse()`를 사용한다.

### 24. 정수 내림차순으로 배치하기

- 리스트 요소들을 정렬할 때, 기본은 __내림차순__이며 오름차순으로 하고 싶을 때에는 옵션으로 `reverse=True`를 준다.

---

## 2020년 1월 13일

### `testBench.py` 추가

- 테스트케이스와 답안 추가를 빠르게 하기 위한 `testBench.py`파일 설계.
- `zip(*iterable)`은 동일한 개수로 이루어진 자료형을 묶어 주는 역할을 하는 함수이다. 예를 들면 아래와 같다.

    ~~~
    >>> list(zip([1, 2, 3], [4, 5, 6]))
    [(1, 4), (2, 5), (3, 6)]

    >>> list(zip("abc", "def"))
    [("a", "d"), ("b", "e"), ("c", "f")]
    ~~~
- `solution` 함수의 실행 시간을 재기 위해서 `time` 라이브러리를 추가함. `time.time()` 구문은 운영체제마다 다른 기준 시간으로부터 현재 시간 까지 몇 초가 흘렀는지 초(s) 단위를 사용하여 반환한다.
- 객체 `s` 가 문자열인지 판단하기 위해서 `isinstance(s, str)`을 사용하였다.
- 함수의 인자가 몇 개인지 조사하기 위해서 `inspect`라이브러리에서 `signature`메소드를 임포트하였다. `signature(function_name).parameters)`로 `function_name`함수의 인자를 반환할 수 있다.
* __리스트 복사__
    - `solution` 함수에 인자가 전달 될 때, mutable한 객체가 전달되는 경우 `solution`에서의 변화가 클래스 변수에 그대로 영향을 끼쳤었다. 따라서 `copy`라이브러리의 `deepcopy` 메서드를 통해서 mutable한 객체를 복사하여 전달하였다. 참고로,
        - 단순 객체 복제는, 그 객체가 mutable한 객체일 때, 동일한 참조를 만드므로 객체의 수정은 참조하고 있는 모든 변수들에 영향을 끼친다.
            ~~~
            >>> a = [1, 2, 3, 4]
            >>> b = a
            >>> a
            [1, 2, 3, 4]
            >>> b
            [1, 2, 3, 4]
            >>> b[0] = 99
            >>> a
            [99, 2, 3, 4]
            >>> b
            [99, 2, 3, 4]
            ~~~
        - mutable하지 않은 객체는 위와 같은 이슈가 발생하지 않는다.
            ~~~
            >>> a = "abc"
            >>> b = a
            >>> a
            abc
            >>> b
            abc
            >>> b = 10
            >>> a
            abc
            >>> b
            10
            ~~~
        - __얕은 복사(shallow copy)__는 mutable한 객체를 새로이 복사하지만, 객체의 각 요소들은 기존 요소들의 참조이다. 얕은 복사는 `copy`라이브러리를 사용하지 않아도 `b = a[:]`로 수행할 수 있다. 복사된 객체의 동일 판별은 `id()`내장 함수를 이용한다.
            ~~~
            >>> import copy
            >>> a = [1, [2, 3]]
            >>> b = copy.copy(a)
            >>> a
            [1, [2, 3]]
            >>> b
            [1, [2, 3]]
            b.append(4)
            >>> a
            [1, [2, 3]]
            >>> b
            [1, [2, 3], 4]
            >>> b[1].append('a')
            >>> a
            [1, [2, 3, 'a']]
            >>> b
            [1, [2, 3, 'a'], 4]
            ~~~
        - __깊은 복사(deep copy)__는 mutable한 객체와 그 요소들까지 모두 새로이 복사한다. 완전히 독립적인 개체가 만들어진다.`
            ~~~
            >>> import copy
            >>> a = [1, [2, 3]]
            >>> b = copy.deepcopy(a)
            >>> a
            [1, [2, 3]]
            >>> b
            [1, [2, 3]]
            b.append(4)
            >>> a
            [1, [2, 3]]
            >>> b
            [1, [2, 3], 4]
            >>> b[1].append('a')
            >>> a
            [1, [2, 3]]
            >>> b
            [1, [2, 3, 'a'], 4]
            ~~~
* 클래스에 대해서
    - __속성(attribute)__
        - 속성은 공개/비공개 여부에 따라서 _공개(public)_ 속성과 _비공개(private)_ 속성으로 나뉜다.
        - 비공개 속성은 속성명 앞에 언더바 두개(`__`)를 붙이면 되며, 이것은 인간의 구별 관행이며 컴퓨터는 공개/비공개를 따로 구분하지 않는다.
        - 속성은 또한 클래스에 속하는지 객체(instance)에 속하는지의 여부에 따라서 클래스 속성과 인스턴스 속성으로 나뉜다.
    - __메서드(method)__
        - 메소드는 인스턴스 메서드와 클래스 메서드, 정적 메서드로 나뉜다.
        - 인스턴스 메서드는 인스턴스가 생성 되어야만 사용할 수 있으며, 클래스 메서드와 정적 메서드는 인스턴스가 없어도 클래스만으로 호출할 수 있다.
        - 그 실행이 외부의 환경에 영향을 미치지 않을 때, 즉 부수 효과(side effect)가 없고 입력 값이 같으면 언제나 같은 값을 반환하는 순수 함수(pure function)인 경우에 사용한다. 
        - 클래스 메서드는 메서드 안에서 클래스 속성, 클래스 메서드에 접근해야 할 때 사용한다.
    - 속성과 메서드에 관한 예제는 다음과 같다.
        ~~~
        >>> class Person:
        ...    person_count = 0
        ...    def __init__(self, _height, _weight):
        ...        Person.person_count += 1
        ...        self.height = _height 
        ...        self.weight = _weight
        ...
        ...    def grow(self):
        ...        self.height += 1
        ...        self.weight += 1
        ...
        ...    @classmethod
        ...    def person_count_sub(cls):
        ...        cls.person_count -= 1
        ...    @classmethod
        ...    def create_persont(cls, _height, _weight):
        ...        p = cls(_height, _weight)
        ...        return p
        ...
        ...    @staticmethod
        ...    def just_add(a, b):
        ...        return a + b

        >>> jaemin = Person(191, 91)
        >>> Person.person_count
        1
        >>> jaewon = Person(168, 50)
        >>> Person.person_list.append("jaewon")
        >>> Person.person_count
        2
        >>> jaemin.height
        191
        >>> jaemin.grow()
        >>> jaemin.height
        192
        >>> Person.person_count_sub()
        >>> Person.person_count
        1
        >>> Person.just_add(2, 3)
        5
        >>> taejin = Person.create_person(170, 70)
        ~~~
---

## 2020년 1월 14일

### 25. 정수 제곱근 판별 0115
 - 테스트 케이스 하나가 통과되지 않아서 고민하였음. 1부터 해당 수의 제곱근까지의 숫자들로 해당 수를 나누면서, 둘이 같은 경우 제곱수라고 생각했는데, 17과 같은 수의 경우 4로 나누면 몫이 4 이지만, 제곱수는 아니다. 해당 수를 해당 수의 제곱근까지의 숫자로 나누었을 때 나머지가 0이라는 조건까지 추가해주어야 한다.

### 26. 제일 작은 수 제거하기
- pass

---

### 27. 홀수 짝수 판별하기
- pass

### 28. 최대공약수와 최소공배수
- 유클리드 호제법으로 최대공약수 구하기
    - 유클리드 호제법이란 어떤 두 수의 최대공약수는 두 수를 나눈 나머지와 한 수의 최대공약수와 같다는 것.
- 최대공약수가 G라면 두 수는 Ga, Gb로 표현할 수 있으며 최소공배수는 Gab이다.

---


### 29. 콜라츠 추측
- pass

## 2020년 1월 15일

### 30. 평균 구하기
- 파이썬 리스트 기본 함수 중에는 평균을 구하는 것은 없다. 직접 구한다.

---

### 31. 하샤드 수
- 정수의 자리수를 추출하는 가장 좋은 방법은 문자열 시퀀스로 바꾼 후 이터레이터에 넣어 한 자리씩 정수로 바꾸는 것인 것 같다.

### 32. 핸드폰 번호 가리기
- 슬라이싱, `[start:end:step]`이지만, `end`는 포함하지 않는다.
    ~~~
    >>> a = "0123456789" 
    >>> a[0:3]
    '012'
    >>> a[0:]
    '0123456789'
    >>> a[4:9]
    '45678'
    >>> a[:]
    '0123456789'
    >>> a[-1]
    '9'
    >>> a[-3:-1]
    '78'
    >>> a[-1:-3]
    ''
    ~~~
---

### 33. 행렬의 덧셈
- 왜 `answer[i][j] = arr1[i] + arr2[j]` 는 안 될까?

## 2020년 1월 16일

### 34. x만큼 간격이 있는 n개의 숫자
- 이건 되는데
    ~~~
    def solution(x, n):
        answer = []
        for i in range(n):
            answer.append(x * (i + 1))
        return answer
    ~~~
- 이건 왜 안될까?
    ~~~
    def solution(x, n):
        return list(range(x, x + n * x, x))
    ~~~

---

## 2020년 1월 16일 

### 35. 0120 직사각형 별 찍기
- pass

### 36. 0120 예산
- 리스트 정렬 메소드 `LIST_NAME.sort()`는 새로운 리스트를 반환하는 게 아니라 리스트 자체 내용물을 정렬시킨다. 따라서 할당할 필요가 없다.

- 리스트 슬라이싱 중, 예를 들어 길이가 5인 리스트인 경우 `LIST_NAME[:5]` 는 리스트 전체를 리턴한다.


### 37. 0121 비밀 지도
- 어떤 숫자를 이진수로 바꿀 때에는 `bin()`을 사용한다.
- `bin()`의 결과는 앞에 `0b`를 포함한다. 이는 `len()`을 사용 할 때 길이가 +2되는 결과를 초래한다.
- `list1, list2`의 결과는 `(list1, list2)`라고 생각하면 편하다. 원소별로 묶을 때에는 `zip()`을 사용한다.

### 38. 0121 실패율
* __`lambda`__에 대해서.
    - 람다 표현식은 익명 함수를 만드는 데에 사용할 수 있다. 우선 기존에 함수를 정의하는 방법인 `def`는 다음과 같았다.
        ~~~
        def plus_one(x):
            return x + 1
        ~~~
    - 이를 람다 표현식을 사용하면 다음과 같이 나타낼 수 있다.
        ~~~
        lambda x: x + 1
        ~~~
    - 익명 함수 호출은 함수 호출기호 `()`를 사용한다.
        ~~~
        >>> (lambda x: x + 1)(1)
        2
        ~~~
    - 매개 변수가 여러개인 경우 아래와 같이 사용하면 된다.
        ~~~
        >>> (lambda x, y, z: x + y + z)(3, 4, 5)
        12
        ~~~
    - 람다식 내에서는 변수를 선언할 수 없다. 다만 바깥에 있는 변수를 사용하는 것은 된다.
        ~~~
        >>> y = 10
        >>> (lambda x: x * 2 + y)(3)
        16
        ~~~
    - 람다 표현식은 `map()`내장 함수 등에 효과적으로 사용될 수 있다.
        ~~~
        >>> l = [1, 2, 3, 4, 5]
        >>> r = list(map(lambda x: x + 1, l))
        >>> r
        [2, 3, 4, 5, 6]
        ~~~
    - `f = lambda x: x + 1`과 같이 람다 표현식에 이름을 붙여 사용할 수도 있다. 
    - 람다식 내에 `if`를 넣으려면 항상 `else`로 거짓인 경우를 확실히 해주어야 한다.
        ~~~
        lambda x: True if x % 2 == 0 else False
        ~~~
    - 만약에 `if`를 여러개 넣고 싶다 하더라도 `elif`는 쓸 수 없다. `if ~ else`문을 연속하여 사용한다. `참일때 결과값 if 조건 else (참일때 결과값 if 조건 else 거짓일 때 결과값)` 처럼 사용한다. 다만 이렇게 사용하는 경우 그냥 `def`표현을 사용하는 것이 나을 것이다.
    - 람다 표현식을 사용하면 `map` 객체를 좀 더 다양하게 이용할 수 있다. 다음은 람다 표현식을 사용하여 `map` 함수를 활용한 예이다. 두 리스트의 각 원소에 대한 사칙연산 결과값을 다른 리스트에 저장하였다.
        ~~~
        >>> a = [1, 2, 3, 4, 5]
        >>> b = [4, 5, 6, 7, 8]
        >>> f = lambda x, y: x * y
        >>> c = map(f, a, b)
        >>> list(c)
        [4, 10, 18, 28, 40]
        ~~~
        
* 정렬에 대해서
    - 레퍼런스는 [여기](https://docs.python.org/ko/3/howto/sorting.html)에서 확인한다.
    * `LIST_NAME.sort()`와 `sorted()`의 차이
        - `LIST_NAME.sort()`는 리스트를 제자리에서 정렬한다. `None`을 반환한다.
        - `sorted(LIST_NAME)`은 정렬된 리스트를 반환한다. 입력된 리스트에는 변화가 없다.
        - 일반적으로 `LIST_NAME.sort()`는 헷갈리며, `sorted()`가 더 편리하다. 하지만 리스트의 원본이 필요하지 않다면 `LIST_NAME.sort()`가 더 효율적이다. 
        - `LIST_NAME.sort()`는 리스트에만 정의되어 있다. 반면에 `sorted()`는 리스트 뿐만 아니라 다른 시퀀스에도 사용 가능하다. 딕셔너리에 사용한 예는 다음과 같다.
        ~~~
        >>> sorted({1:'A', 3:'D', 2:'B'})
        [1, 2, 3]
        ~~~

        * `LIST_NAME.sort()`와 `sorted()`의 `key` 매개변수, __특정 값을 기준으로 하여 정렬하기__
            - `LIST_NAME.sort()`와 `sorted()`는 모두 각 리스트 요소에 적용할 함수를 지정하는 `key` 매개변수를 가지고 있다.
            - 예를 들어, 대소문자 구별 없이 정렬하려면 다음과 같이 사용한다.
            ~~~
            >>> sorted("This is my first sorting example.".split(), key=str.lower)
            ['example.', 'first', 'is', 'my', 'sorting', 'This'] 
            ~~~
            - 일반적으로는 다음과 같이 객체의 자료구조가 복잡한 경우 사용한다.
            ~~~
            >>> students = [('Andy', 30, 191), ('Anna', 23, 180), ('James', 40, 140)]
            >>> students.sort(key=lambda x: x[1])
            >>> studnets
            [('Anna', 23, 180), ('Andy', 30, 191), ('James', 40, 140)]
            ~~~

- [유형] 인덱스가 중요한 리스트 정렬하기?



    



